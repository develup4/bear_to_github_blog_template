# 서블릿
(김영한 님)

스프링부트는 서블릿을 포함하고 있으므로(wrapping하였으니 당연하게도), 예제 코드는 모두 스프링 내에서 작성한 버전으로 한다.

```java
@ServletComponentScan // 서블릿 자동 등록
@SpringBootApplication
public class ServletApplication {
  public static void main(String[] args) {
    SpringApplication.run(ServletApplication.class, args);
  }
}
```

위와 같은 애노테이션을 통해 서블릿을 자동등록하도록 한 뒤, 첫 서블릿을 생성하여 등록하도록 하자.

```java
@WebServlet(name = "helloServlet", urlPatterns = "/hello")
public class HelloServlet extends HttpServlet {
  @Override
  protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    System.out.println("HelloServlet.service");
    System.out.println("request = " + request);
    System.out.println("response = " + response);
    String username = request.getParameter("username");
    System.out.println("username = " + username);
    response.setContentType("text/plain");
    response.setCharacterEncoding("utf-8");
    response.getWriter().write("hello " + username)
  }
}
```

다짜고짜 코드부터 살펴보았는데 간단히 살펴보면 아직 설명하지 않은 `서블릿`이 무엇인지를 알 수 있을 것이다. 간단하게 설명하자면 **웹 요청을 처리**하기 위한 자바 클래스인 것이다.

`@WebServlet` 서블릿 애노테이션을 통해 서블릿 클래스를 등록할 수 있으며, name 및 urlPatterns을 정의할 수 있다. 위 예제의 서블릿은 `http://localhost:8080/hello`에 대한 웹 요청을 처리할 수 있는 것이다.

서블릿은 `서블릿 컨테이너`에 보관되며 매치되는 url로 요청이 오면 아래와 같은 메서드가 호출된다. 개발자는 이 메서드를 오버라이딩해서 해당 요청에 대한 동작을 정의하는 것이다.

```java
protected void service(HttpServletRequest request, HttpServletResponse response)
```

현재의 스프링부트나 다른 웹 프레임워크를 생각해보면 아쉬울 수도 있지만, 이미 서블릿만으로도 http request에 대한 추상화가 많이 이루어져 있다. HttpServletRequest라는 클래스가 이미 request를 추상화했다는 의미가 되지 않겠는가? 간단히 예를 들면 Http request header의 Content-Length만 해도 계산없이 자동으로 서블릿에 제공이 된다.

그렇다면 서블릿들이 저장되는 서블릿 컨테이너는 어디에 있는걸까? 정답은 톰켓(Tomcat) 서버이다. 스프링부트를 통해 서블릿을 작성하면 내장된 톰켓 서버를 통해 서블릿이 실행되는 것이다. 확실히 WAS답게 단순한 웹 서버와는 달리 로직을 보관한다.


## HttpServletRequest


이제 좀 더 디테일하게 서블릿의 요소를 살펴보자. 먼저 `HttpServletRequest`이다. 서블릿은 개발자 대신 http request message를 파싱해서 위 클래스의 객체를 생성하고 service 메서드의 인자로 넣어준다.

구체적으로 제공해줄 수 있는 데이터는 아래와 같다.

- HTTP 메소드(GET, POST, DELETE, PUT, ...)
- URL
- query string
- 스키마
- 프로토콜 헤더
- form 파라미터 형식 조회
- message body 데이터 직접 조회

이것만으로는 재미가 없다. 파싱정도는 시시하지 않겠는가? 부가적인 기능을 아래와 같이 제공한다.

- **임시 저장소 기능**
해당 HTTP 요청이 시작부터 끝날 때 까지 유지되는 임시 저장소를 제공한다. 나중에도 핵심적으로 쓰게되는 기능이니 기억해두자.

```java
request.setAttribute(name, value)
request.getAttribute(name)
```

- 세션 관리 기능

```java
request.getSession(create: true)
```


실제 사용방법에 대해 예제를 통해 상세하게 알아보자.

```java
private void printStartLine(HttpServletRequest request) {
request.getMethod()); // GET
 request.getProtocol()); // HTTP/1.1
 request.getScheme()); // http
 request.getRequestURL()); // http://localhost:8080/request-header
 request.getRequestURI()); // /request-test
 request.getQueryString()); // username=hi
 request.isSecure()); // https 사용 유무

request.getHeaderNames().asIterator().forEachRemaining(headerName -> System.out.println(headerName + ":" + request.getHeader(headerName)));
}

request.getServerName()); //Host 헤더      

request.getServerPort()); //Host 헤더
request.getLocales().asIterator().forEachRemaining(locale -> request.getLocale());

System.out.println("[cookie 편의 조회]"); if (request.getCookies() != null) {
        for (Cookie cookie : request.getCookies()) {
            System.out.println(cookie.getName() + ": " + cookie.getValue());
} }

System.out.println("[Content 편의 조회]");

request.getContentType());
request.getContentLength());

  request.getCharacterEncoding())

System.out.println("[Remote 정보]");

  request.getRemoteHost()); //
 request.getRemoteAddr()); //
 request.getRemotePort()); //

System.out.println("[Local 정보]");
 request.getLocalName()); //
 request.getLocalAddr()); //
 request.getLocalPort()); //
```

이렇게 HttpRequest에 대한 대부분의 정보를 API를 통해 얻어올 수 있다. 스프링에서도 필요시 사용할 수 있으므로 필요할때 레퍼런스를 찾아보도록 하자.


### GET 메소드의 Query String 얻어오기

`http://localhost:8080/request-param?username=hello&age=20`

위와 같은 url이 있을 때 어떻게 파라메터를 얻어올 수 있을까? 사용자가 직접 url을 파싱할 필요는 없다. 아래와 같은 방식으로 쿼리 스트링을 얻어오자. 그리고 나중에 스프링가면 훨씬 더 편리한 방식으로 얻어올 수 있다.

```java
@WebServlet(name = "requestParamServlet", urlPatterns = "/request-param")
public class RequestParamServlet extends HttpServlet {
   @Override
   protected void service(HttpServletRequest request, HttpServletResponse resp) throws ServletException, IOException                      
   {
      System.out.println("[전체 파라미터 조회] - start");
      request.getParameterNames().asIterator()
                  .forEachRemaining(paramName -> System.out.println(paramName +
"=" + request.getParameter(paramName))); System.out.println("[전체 파라미터 조회] - end");
          System.out.println();
System.out.println("[단일 파라미터 조회]");
String username = request.getParameter("username"); System.out.println("request.getParameter(username) = " + username);
          String age = request.getParameter("age");
          System.out.println("request.getParameter(age) = " + age);
          System.out.println();
System.out.println("[이름이 같은 복수 파라미터 조회]"); System.out.println("request.getParameterValues(username)"); String[] usernames = request.getParameterValues("username");

      for (String name : usernames) {
              System.out.println("username=" + name);
          }
          resp.getWriter().write("ok");
      }
}
```


### Form을 활용한 POST 메시지의 body 파싱

- 이 경우 메시지 바디의 형식은 GET 방식 url의 쿼리 스트링과 형식이 동일히다. 따라서 동일한 api를사용하여 얻어올 수 있다.


content-type: application/x-www-form-urlencoded

username=hello&age=20


application/x-www-form-urlencoded 형식은 앞서 GET에서 살펴본 쿼리 파라미터 형식과 같다. 따라서 쿼리 파라미터 조회 메서드를 그대로 사용하면 된다.
클라이언트(웹 브라우저) 입장에서는 두 방식에 차이가 있지만, 서버 입장에서는 둘의 형식이 동일하므로, request.getParameter() 로 편리하게 구분없이 조회할 수 있다.
정리하면 request.getParameter() 는 GET URL 쿼리 파라미터 형식도 지원하고, POST HTML Form 형식도 둘 다 지원한다.



### JSON 형식의 POST 메시지 해석

POST http://localhost:8080/request-body-json
content-type: application/json
message body: 
{"username": "hello", "age": 20} 결과: messageBody = {"username": "hello", "age": 20}


JSON 형식을 받아서 바로 객체로 만들어보자. 마치 node.js와 javascript간에 그러하듯이

```java
  @Getter @Setter
  public class HelloData {
      private String username;
      private int age;
  }
```


```java

import com.fasterxml.jackson.databind.ObjectMapper;
// 이 녀석이 json을 object로 매핑해준다.


@WebServlet(name = "requestBodyJsonServlet", urlPatterns = "/request-body-
    json")
    public class RequestBodyJsonServlet extends HttpServlet {
        private ObjectMapper objectMapper = new ObjectMapper();
@Override
        protected void service(HttpServletRequest request, HttpServletResponse
    response)
                throws ServletException, IOException {
            ServletInputStream inputStream = request.getInputStream();
String messageBody = StreamUtils.copyToString(inputStream,
    StandardCharsets.UTF_8);
            System.out.println("messageBody = " + messageBody);
            HelloData helloData = objectMapper.readValue(messageBody,
    HelloData.class);
            System.out.println("helloData.username = " + helloData.getUsername());
            System.out.println("helloData.age = " + helloData.getAge());
            response.getWriter().write("ok");
        }
}
```

그냥 쓱 넣으면 끝나는 node.js보다는 좀 불편하다. 잭슨이라는 라이브러리의 오브젝트 매퍼를 활용해야 한다. 근데 나중에 스프링으로 가면 노드만큼 편하게 가능하다.



## HttpServletResponse

HttpServletResponse 역할
HTTP 응답 메시지 생성 HTTP 응답코드 지정 헤더 생성
바디 생성
편의 기능 제공
Content-Type, 쿠키, Redirect


request와 마찬가지로 response도 편의기능을 많이 제공한다. 그리고 역시나 스프링에서는 더 편하게 제공한다.


```java
 @WebServlet(name = "responseHeaderServlet", urlPatterns = "/response-header")
  public class ResponseHeaderServlet extends HttpServlet {
 @Override
protected void service(HttpServletRequest request, HttpServletResponse
  response)
              throws ServletException, IOException {
          //[status-line]
          response.setStatus(HttpServletResponse.SC_OK); //200
          //[response-headers]
          response.setHeader("Content-Type", "text/plain;charset=utf-8");
          response.setHeader("Cache-Control", "no-cache, no-store, must-
  revalidate");
          response.setHeader("Pragma", "no-cache");
          response.setHeader("my-header","hello");
// content
//Content-Type: text/plain;charset=utf-8
//Content-Length: 2
//response.setHeader("Content-Type", "text/plain;charset=utf-8");
response.setContentType("text/plain"); response.setCharacterEncoding("utf-8"); //response.setContentLength(2); //(생략시 자동 생성)

// cookie
//Set-Cookie: myCookie=good; Max-Age=600; //response.setHeader("Set-Cookie", "myCookie=good; Max-Age=600"); 

Cookie cookie = new Cookie("myCookie", "good"); cookie.setMaxAge(600); //600초
      response.addCookie(cookie);

// redirect
 //Status Code 302
      //Location: /basic/hello-form.html
      //response.setStatus(HttpServletResponse.SC_FOUND); //302
      //response.setHeader("Location", "/basic/hello-form.html");
      response.sendRedirect("/basic/hello-form.html");

//[message body]
          PrintWriter writer = response.getWriter();
          writer.println("ok");
      }
}
```


이제 response 메시지의 body를 작성하는 다양한 방법에 대해 알아보자.

```java
PrintWriter writer = response.getWriter(); writer.println("<html>"); writer.println("<body>");
writer.println(" <div>안녕?</div>"); writer.println("</body>"); writer.println("</html>");
```

뭔가 학부시절 잘알지도 못하면서 쓰던 파일입출력과 비슷한 형태를 기본적으로 제공한다.


이번에는 실전적으로 JSON 응답을 만드는 법이다. 사용법은 직관적이다.

```java
 //Content-Type: application/json
          response.setHeader("content-type", "application/json");
          response.setCharacterEncoding("utf-8")

HelloData data = new HelloData();
          data.setUsername("kim");
   data.setAge(20);
            //{"username":"kim","age":20}
            String result = objectMapper.writeValueAsString(data);
            response.getWriter().write(result);
```


> 참고  
> application/json 은 스펙상 utf-8 형식을 사용하도록 정의되어 있다. 그래서 스펙에서 charset=utf-8  
과 같은 추가 파라미터를 지원하지 않는다. 따라서 application/json 이라고만 사용해야지
> application/json;charset=utf-8 이라고 전달하는 것은 의미 없는 파라미터를 추가한 것이 된다. > response.getWriter()를 사용하면 추가 파라미터를 자동으로 추가해버린다. 이때는  
response.getOutputStream()으로 출력하면 그런 문제가 없다.


