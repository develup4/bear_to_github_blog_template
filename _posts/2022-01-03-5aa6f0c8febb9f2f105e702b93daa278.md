---
title:  클래스와 인터페이스

subtitle:  Effective JAVA
categories: java 
tags: effective_java  class  interface
 
toc: true
toc_sticky: true
---

  
## ITEM15: 클래스와 멤버의 접근 권한을 최소화하라  
- 사실 두말하면 잔소리다.  
- 정보 은닉, 캡슐화는 소프트웨어 설계의 근간이 되는 원리이다.  
- public 등  `API`는 하위 호환을 위해 **영원히** 관리해줘야 한다.  
  
### 특히나 자바의 경우에는  
- 패키지 외부에서 쓸 이유가 없다면  `package-private`으로 선언하자.  
- 한 클래스에서만 사용하는 package-private 클래스나 인터페이스를 `private static`으로 중첩해서 사용하자. 이 경우 바깥 클래스 하나에서만 접근할 수 있다.  
- public일 필요가 없는 **클래스**의 접근 수준을 package-private로 좁혀두자.  
- `Serializable`을 구현한 클래스에서는 그 필드들도 의도치 않게 공개 API가 될 수 있다.  
-  Overriding을 할때는 상위 클래스에서의 접근 수준보다 좁게 지정할 수 없다. 이는 `리스코프 치환법칙`이다.  
- 해당 클래스가 추상 개념을 완성하는데 꼭 필요한 구성요소로서의 상수라면 `public static final` 필드로 공개해도 좋다. 이 경우 대문자와 언더스코어(_)를 통해 명명하고 값은 반드시 값이나 **불변 객체**이어야 한다.  
- `길이가 0이 아닌 배열`은 참조이므로 변경 가능하다. 주의해야 한다.  
  
### 모듈 시스템  
- Java9부터 도입되었다.  
- 모듈은 패키지의 묶음이다. 패키지 중 공개(export)할 것들을 (관례상 `module-info.java` 파일에 선언한다.  
- 접근 지정자와 상관없이 위 파일에 공개되지 않은 패키지는 외부에서 접근할 수 없다.  
- JDK 자체가 이를 적극 활용하였다. 자바 라이브러리에서 공개하지 않은 패키지들은 외부에서 접근할 수 없다.  
  
  
## ITEM16: public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라  
- 오히려 너무 당연한 말이라서 public으로 써도 좋을만한 사례만 정리한다.  
- `package-private` 클래스 혹은  `private` 중첩 클래스라면 **데이터 필드를 노출한다해도 문제가 없다**.  
- 그 클래스가 표현하려는 추상 개념만 올바르게 표현해주면 된다.  
- 클라이언트도 어차피 이 클래스를 포함하는 패키지 안에서만 동작하는 코드일 뿐이기 때문이다.  
- 이는 접근자 방식보다 깔끔하다.  
  
  
## ITEM17: 변경 가능성을 최소화하라  
- 불변 클래스란 그 인스턴스의 내부 값을 수정할 수 없는 클래스이다.  
- 아래 다섯가지 규칙을 따르면 불변 클래스라 할 수 있다.  
  
> 객체의 상태를 변경하는 메소드를 제공하지 않는다.    
> 클래스를 확장할 수 없도록 한다    
> 모든 필드를 final로 선언한다.    
> 모든 필드를 private으로 선언한다.    
> 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.    
  
### 불변 객체의 예  
  
```java  
public final class Complex {  
	private final double re;  
	private final double im;  
  
	// 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.  
	public Complex(double re, double im) {  
		this.re = re;  
		this.im = im;  
	}  
  
	public Complex plus(Complex c) {  
		return new Complex(re + c.re, im + c.im);  
	}  
}  
```  
  
### 불변 객체의 장점  
- 불변 객체는 단순하다.  
- 근본적으로 스레드에 안전하여 따로 동기화할 필요가 없다. 따라서 안심하고 공유할 수 있다.  
- 정적 팩토리 메소드 등을 통해 인스턴스를 중복 생성하지 않도록 캐싱할 수 있다.  
  
### 불변 객체의 단점  
- 단점으로는 원하는 객체를 완성하기까지 단계가 많고, 그 중간 단계에서 만들어진 객체들이 모두 버려진다면 성능 문제가 있을 수 있다는 것이다. 대표적인 예가 `String`과 같은 클래스이다.  
- 이런 경우 `가변 동반 클래스(companion class)`를 package-private으로 두곤 한다.  
- String의 경우 가변 동반 클래스로 `StringBuilder`를 두고 있다.  
  
### 함수형 프로그래밍  
- 피연산자에 함수를 적용해 그 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴을 말한다.  
- 위 코드에서  `plus`는 `new`를 통해 새로운 객체를 반환한다. 따라서 내부 상태가 변하지 않으므로 함수형 프로그래밍이다.  
  
  
## ITEM18: 상속보다는 컴포지션을 사용하라  
- 이번도 너무 당연한 이야기다. C++에서도 상속은 `friend` 다음으로 강력한 결합이다.  
- 메소드 호출과는 달리 상속은 캡슐화를 깨뜨린다.  
- 상속은 결함까지도 상속함을 주의한다. 또한 어떻게 `overriding`될지 모르기에 미래의 동작을 예측할 수 없다.  
- 기존 클래스를 새로운 클래스의 **구성요소**로 쓴다고 하여 이러한 설계를 `컴포지션(composition)`이라 한다.  
- 기존 클래스의 API를 호출하는 것을 `forwarding`, 그 호출하는 메소드를 `forwarding method`라고 부른다.  
- 상속은 반드시 하위 클래스가 상위 클래스의 **진짜** 하위 타입인 상황(`is-a`)에서만 쓰여야 한다.  
  
### SELF 문제  
- 컴포지션은 거의 단점이 없지만 Callback 형태의 구조에서 취약점이 있다.  
- 내부 객체는 자신을 감싸고 있는 wrapper의 존재를 모르므로 자신(this)의 참조를 넘기게 되고, 콜백 때 wrapper가 아닌 자신이 호출되게 된다. 이러한 문제를 `SELF` 문제라 하며 주의해야 한다.  
  
  
## ITEM19: 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라  
- 상속은 ITEM18에서 보듯 위험한 기술이지만 그만큼 강력한 기술이기도 하다.  
- 사용한다면 `protected` 메소드를 최소화하는게 좋지만, 너무 적게 노출해서 상속으로 얻는 이점마저 없애지 않도록 주의해야 한다.  
- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하다.  
- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 **재정의 가능 메소드**를 호출해서는 안된다. 상위 클래스의 생성자가 먼저 호출되고, 어떻게 동작할지 하위 클래스에 달려 있어 장담할 수 없다.  
- `Cloneable`이나 `Serializable` 인터페이스를 구현한 클래스는 상속을 허용하면 일반적으로 좋지 않다.  
  
### 상속을 금지하는 방법  
- 클래스를 `final`로 선언하면 상속을 금지할 수 있다.  
- 모든 생성자를 `private`이나 `package-private`으로 선언하고 public 정적 팩토리를 만들어주는 방법도 있다.  
