---
title:  Kafka

categories: microservice 
tags: message_broker  kafka
 
---

  
여러 마이크로 서비스간의 복잡성이 커지면 유지보수나 배포에 어려움이 있기 때문에 복잡성을 줄이기 위해서 아파치에서 개발하였다. 생산자 소비자 모델을 통해 카프카하고만 통신을 하면 된다.  
  
- 토픽  
카프카에는 다양한 데이터가 들어가게 되는데, 그 데이터가 들어가는 공간을 토픽이라고 한다. 토픽을 여러개 생성할 수 있다. 파일시스템의 디렉토리나 데이터베이스의 테이블과 비슷한 요소이다. 예를 들어 클릭로그, sms,location_log이런식이 될 수 잇따.  
  
- 파티션  
하나의 토픽은 여러개의 파티션으로 나뉠 수 있으며 하나하나가 메시지큐라고 할 수 있다. 생산자 소비자가 순서대로 넣고 순서대로 뺀다. 다만 빼더라도 데이터가 삭제되는것은 아니고 포인터만 이동한다. 왜냐하면 다른 소비자가 있는 경우 다시 큐의 끝부터 시작해서 가져갈 수도 있기 때문이다(설정에 따라 다르다) => 동일 데이터에서 두번이상 사용이 가능한데 카프카의 중요한 기능 중 하나이다. 예를 들어 로그를 하둡과 엘라스틱 서치등에 각각 넣을수도 있따.  
이렇게 데이터가 삭제되지 않는 특성이 카프카를 데이터 파이프라인으로 쓰기에 적절하게 만든다.  
  
- 파티션이 여러개 있는 경우  
키가 없다면 라운드로빈으로 다음 파티션에 데이터가 들어가게 되고, 키가 있다면 특정 파티션으로 데이터가 들어간다.  
파티션은 늘릴 수 있지만 줄일수 없다.  
파티션을 늘리는 이유는 컨슈머를 늘려서 데이터를 분산처리할 수 있기 때문이다.  
데이터 삭제 정책은 따로 설정할 수 있따.  
  
- replication  
파티션의 복제본을 의미한다. 리드 파티션과 리플릭케이션(follow partition)을 묶어서 in sync replica(isr)이라고 부른다.  
=> 고가용성을 위해 사용(레이드같은 개념), 속도와 고가용성의 트레이드 오프  
보통 레플릭케이션은 3으로 설정하는것이 좋다고 한다.  
  
- 파티셔너  
프로듀서가 데이터를 넣을때 파티셔너를 거치게된다. 파티셔너가 어떤 파티션에 데이터를 넣을지를 결정하게 된다. 해시로직이 있어서 이것에 의해 결정된다. 기본 파티셔너 외에도 직접 구현도 가능하다. 예를 들어 vip유저를 위한 파티셔너를 만들 수도 있을것이다.  
  
- 컨슈머 랙(lag)  
생산자 인덱스와 소비자 인덱스간의 거리가 멀다면 소비자 속도가 느리다는거다. 이 수치로 상태를 유추할 수 잇따.  
  
- Borrow  
오픈소스이다. consumer lag을 모니터링하기 위한 오픈소스. 도구이다. 컨슈머를 통해서 모니터링하는것은 비용이 크므로 이런 오픈소스를 쓰도록 하자.  
  
- 카프카를 직접 서버에 운영하지 않아도 SaaS형태로 사용가능한 서비스가 있는데 AWS의 MSK(Managed Streaming for Kafka)와 Confluent의 Cloud Kafka  
웹인터페이스를 통해 바로 사용이 가능  
  
