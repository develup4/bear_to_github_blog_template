---
title:  (Câºâº) ğŸ§µThread

subtitle:  in Android Native
categories: í”„ë¡œê·¸ë˜ë°ì–¸ì–´ 
tags: cpp  android  Thread
 
---

  
  
```cpp  
#include <stdio.h>  
#include <pthread.h>  
#include "StrongPointer.h"  
#include "RefBase.h"  
  
using namespace android;  
  
void *foo(void* data)  
{  
	printf("foo()\n");  
	return 0;  
}  
  
int main()  
{  
	pthread_t thread;  
	pthread_create( &thread, 0, foo, 0 );  
	pthread_join( thread, 0 );  
	return 0;  
}  
```  
  
AndroidëŠ” Linux ìœ„ì— ì˜¬ë¼ê°€ ìˆìœ¼ë¯€ë¡œ ë¦¬ëˆ…ìŠ¤ì—ì„œì˜ ì“°ë ˆë“œë¶€í„° ì‚´í´ë³´ë©´,  
ê¸°ë³¸ì ì¸ POSIX threadëŠ” ìœ„ì™€ ê°™ì´ ì‚¬ìš©í•œë‹¤.  
  
```cpp  
#include <stdio.h>  
#include <pthread.h>  
#include "StrongPointer.h"  
#include "RefBase.h"  
  
using namespace android;  
  
class Thread  
{  
	pthread_t thread;  
public:  
	virtual void foo(void) = 0;  
	static void *_foo(void* data)  
	{  
		Thread *self = static_cast<Thread*>(data);  
		self->foo();  
		return 0;  
	}  
	void run() { pthread_create( &thread, 0, _foo, this ); }  
	void join() { pthread_join( thread, 0 ); }  
};  
  
class MyThread : public Thread  
{  
public:  
	void foo(void)  
	{  
		printf("MyThread::foo()\n");  
	}  
};  
  
int main()  
{  
	MyThread thread;  
	thread.run();  
	thread.join();  
	return 0;  
}  
```  
  
ì´ê²ƒì„ í´ë˜ìŠ¤ë¡œ wrappingí•˜ë©´ ì´ë ‡ê²Œë„ ì“¸ ìˆ˜ ìˆì„ê²ƒì´ë‹¤.  
ë§ˆì°¬ê°€ì§€ë¡œ Androidì—ì„œë„ POSIX threadë¥¼ wrapí•´ì„œ êµ¬í˜„í•´ë†“ì•˜ëŠ”ë°,  
  
```cpp  
#ifndef _LIBS_UTILS_THREAD_H  
#define _LIBS_UTILS_THREAD_H  
  
#include <stdint.h>  
#include <sys/types.h>  
#include <time.h>  
  
#if !defined(_WIN32)  
# include <pthread.h>  
#endif  
  
#include "Condition.h"  
#include "Errors.h"  
#include "Mutex.h"  
#include "RefBase.h"  
#include "Timers.h"  
#include "ThreadDefs.h"  
  
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”  
namespace android {  
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”  
  
// DO NOT USE: please use std::thread  
  
class Thread : virtual public RefBase  
{  
public:  
    // Create a Thread object, but doesnâ€™t create or start the associated  
    // thread. See the run() method.  
    explicit            Thread(bool canCallJava = true);  
    virtual             ~Thread();  
  
    // Start the thread in threadLoop() which needs to be implemented.  
    // NOLINTNEXTLINE(google-default-arguments)  
    virtual status_t    run(    const char* name,  
                                int32_t priority = PRIORITY_DEFAULT,  
                                size_t stack = 0);  
      
    // Ask this objectâ€™s thread to exit. This function is asynchronous, when the  
    // function returns the thread might still be running. Of course, this  
    // function can be called from a different thread.  
    virtual void        requestExit();  
  
    // Good place to do one-time initializations  
    virtual status_t    readyToRun();  
      
    // Call requestExit() and wait until this objectâ€™s thread exits.  
    // BE VERY CAREFUL of deadlocks. In particular, it would be silly to call  
    // this function from this objectâ€™s thread. Will return WOULD_BLOCK in  
    // that case.  
            status_t    requestExitAndWait();  
  
    // Wait until this objectâ€™s thread exits. Returns immediately if not yet running.  
    // Do not call from this objectâ€™s thread; will return WOULD_BLOCK in that case.  
            status_t    join();  
  
    // Indicates whether this thread is running or not.  
            bool        isRunning() const;  
  
#if defined(__ANDROID__)  
    // Return the threadâ€™s kernel ID, same as the thread itself calling gettid(),  
    // or -1 if the thread is not running.  
            pid_t       getTid() const;  
#endif  
  
protected:  
    // exitPending() returns true if requestExit() has been called.  
            bool        exitPending() const;  
      
private:  
    // Derived class must implement threadLoop(). The thread starts its life  
    // here. There are two ways of using the Thread object:  
    // 1) loop: if threadLoop() returns true, it will be called again if  
    //          requestExit() wasnâ€™t called.  
    // 2) once: if threadLoop() returns false, the thread will exit upon return.  
    virtual bool        threadLoop() = 0;  
  
private:  
    Thread& operator=(const Thread&);  
    static  int             _threadLoop(void* user);  
    const   bool            mCanCallJava;  
    // always hold mLock when reading or writing  
            thread_id_t     mThread;  
    mutable Mutex           mLock;  
            Condition       mThreadExitedCondition;  
            status_t        mStatus;  
    // note that all accesses of mExitPending and mRunning need to hold mLock  
    volatile bool           mExitPending;  
    volatile bool           mRunning;  
            sp<Thread>      mHoldSelf;  
#if defined(__ANDROID__)  
    // legacy for debugging, not used by getTid() as it is set by the child thread  
    // and so is not initialized until the child reaches that point  
            pid_t           mTid;  
#endif  
};  
  
}  // namespace android  
  
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”  
#endif // _LIBS_UTILS_THREAD_H  
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”  
```  
  
ì´ê²ƒì €ê²ƒ êµ¬í˜„ì‚¬í•­ì€ ë§ì§€ë§Œ ê¸°ë³¸ì ì¸ ë™ì‘ì€ ì¸í„°í˜ì´ìŠ¤ë§Œ ë´ë„ ì§ì‘í•  ìˆ˜ ìˆë‹¤.  
  
ì£¼ì˜í• ë§Œí•œ ì‚¬í•­ì€ **ì“°ë ˆë“œ ê°ì²´ë¥¼ ë‚´ë¶€ì—ì„œ strong pointerë¡œ ë§Œë“  ë’¤, refCountë¥¼ ìì²´ì ìœ¼ë¡œ 1 ê°ì†Œì‹œí‚¨ë‹¤ëŠ” ì **ì´ë‹¤.  
ê·¸ë˜ì„œ ì¼ë°˜ í¬ì¸í„°ë¡œ Android ì“°ë ˆë“œë¥¼ ì‚¬ìš©í•˜ë©´ refCountê°€ 0ì´ ë˜ì–´ë²„ë¦¬ë¯€ë¡œ ì •ìƒì ìœ¼ë¡œ ëŒì§€ì•ŠëŠ”ë‹¤.  
  
**ì¦‰, ë°˜ë“œì‹œ spë¥¼ ì¨ì„œ ì‚¬ìš©í•´ì•¼í•œë‹¤.** as below  
  
```cpp  
using namespace android;  
  
class MyThread : public Thread  
{  
public:  
	bool threadLoop()  
	{  
		printf("MyThread::foo()\n");  
		sleep(2);  
		return true;  
	}  
};  
  
int main()  
{  
	sp<Thread> thread = new MyThread;  
	thread->run("MyThread");  
	thread->join();  
	return 0;  
}  
```  
  
ë‹¤ìŒìœ¼ë¡œ ì‚´í´ë³¼ ë‚´ìš©ì€ Androidì—ì„œ ì œê³µí•˜ëŠ” `Mutex`ì´ë‹¤.  
  
```cpp  
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;  
int sum = 0;  
  
class MyThread : public Thread  
{  
public:  
	bool threadLoop()  
	{  
		int local;  
		for(int i=0; i<10000000; i++)  
		{  
			pthread_mutex_lock(&mutex);  
			local = sum;  
			local = local + 1;  
			sum = local;  
			pthread_mutex_unlock(&mutex);  
		}  
				  
		return false;  
	}  
};  
  
int main()  
{  
	sp<Thread> thread1 = new MyThread;  
	thread1->run("MyThread1");  
	sp<Thread> thread2 = new MyThread;  
	thread2->run("MyThread2");  
  
	thread1->join();  
	thread2->join();  
	printf("sum = %d\n", sum );  
	return 0;  
}  
```  
  
ì—­ì‹œë‚˜ POSIX mutexë¶€í„° ì‚´í´ë³´ë©´ ìœ„ì™€ ê°™ì´ ì‚¬ìš©í•œë‹¤.  
  
```cpp  
using namespace android;  
  
Mutex mutex;  
int sum = 0;  
  
class MyThread : public Thread  
{  
public:  
	bool threadLoop()  
	{  
		int local;  
		for(int i=0; i<10000000; i++)  
		{  
			mutex.lock();  
			local = sum;  
			local = local + 1;  
			sum = local;  
			mutex.unlock();  
		}  
				  
		return false;  
	}  
};  
```  
  
ê·¸ë¦¬ê³  ë” í¸í•˜ê²Œ ì‚¬ìš©í•˜ê¸° ìœ„í•´ ì—­ì‹œë‚˜ Androidì—ì„œ wrapper í´ë˜ìŠ¤ë¥¼ ì œê³µí•˜ëŠ”ë°,  
ë‹¤ë§Œ ì—¬ê¸°ì„œ ì£¼ì˜í•  ì‚¬í•­ì´ ìˆë‹¤.  
  
ì´ ~ì„ê³„ì˜ì—­(Critical section)ì—ì„œ ì˜ˆì™¸ë°œìƒì‹œ unlockì´ ì•ˆë˜ëŠ” ë¬¸ì œê°€ ìˆì„ ìˆ˜ ìˆë‹¤~ëŠ”ê²ƒì´ë‹¤.  
ê·¸ë ‡ë‹¤ê³  ëª¨ë“  catchì—ì„œ unlockì„ í•˜ëŠ” ê²ƒë„ ë­”ê°€ ë¶ˆí•©ë¦¬í•˜ë‹¤.  
  
ê·¸ë˜ì„œ Androidì—ì„œ `autolock`ì´ë¼ëŠ” ê²ƒì„ ì œê³µì„ í•œë‹¤.  
ì´ê²ƒë„ ì—­ì‹œ RAII ê°œë…(ìì›ì˜ ê´€ë¦¬ëŠ” ê°ì²´)ì´ë‹¤.  
  
```cpp  
Mutex mutex;  
int sum = 0;  
  
class MyThread : public Thread  
{  
public:  
	bool threadLoop()  
	{  
		int local;  
		for(int i=0; i<10000000; i++)  
		{  
			Mutex::Autolock ll(mutex);  
			local = sum;  
			local = local + 1;  
			sum = local;  
		}  
				  
		return false;  
	}  
};  
```  
  
Autolockì€ ì˜ˆì™¸ê°€ ë°œìƒí•˜ë”ë¼ë„ ìë™ìœ¼ë¡œ unlockì„ í•´ì¤€ë‹¤.  
(call stackì— ì•ˆë‚¨ë‚˜â€¦?)  
  
  
ì´ë²ˆì—” `Conditional`ì— ëŒ€í•´ ì•Œì•„ë³´ì.  
  
ì¼ë°˜ì ì¸ ìƒì‚°ì ì†Œë¹„ì ëª¨ë¸ì´ ìˆì„ë•Œ ê°ê°ì´ ë³„ê°œì˜ ì“°ë ˆë“œì—ì„œ ë™ì‘í•œë‹¤ë©´,  
ìƒì‚°ë„ ì•ˆí–ˆëŠ”ë° ì†Œë¹„ìê°€ ì‘ë™í•˜ëŠ” ë¬¸ì œê°€ ìˆì„ ìˆ˜ ìˆë‹¤. ~ì¼ì˜ ìˆœì„œê°€ ìˆëŠ” ê²ƒì´ë‹¤.~  
  
ì´ëŸ° ë¬¸ì œë¥¼ ìœ„í•´ POSIXëŠ” pthread_cond_wait, pthread_cond_signal ë“±ì˜ apië¥¼ ì œê³µí•œë‹¤.  
  
```cpp  
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;  
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;  
  
class Producer: public Thread  
{  
public:  
	bool threadLoop()  
	{  
		pthread_mutex_lock(&mutex);  
		for(int i=0; i<3; i++)  
		{  
			sleep(1);  
			printf("ìƒì‚°ì¤‘â€¦\n");  
		}  
		printf("ìƒì‚°ì™„ë£Œ\n");  
		pthread_cond_signal(&cond);  
		pthread_mutex_unlock(&mutex);  
				  
		return false;  
	}  
};  
class Consumer : public Thread  
{  
public:  
	bool threadLoop()  
	{  
		pthread_mutex_lock(&mutex);  
		pthread_cond_wait(&cond, &mutex);  
		for(int i=0; i<3; i++)  
		{  
			sleep(1);  
			printf("ì†Œë¹„ì¤‘â€¦\n");  
		}  
		printf("ì†Œë¹„ì™„ë£Œ\n");  
		pthread_mutex_unlock(&mutex);  
				  
		return false;  
	}  
};  
  
int main()  
{  
	sp<Thread> pro = new Producer;  
	pro->run("Producer");  
	sp<Thread> con = new Consumer;  
	con->run("Consumer");  
  
	pro->join();  
	con->join();  
	return 0;  
}  
```  
  
ê·¸ë¦¬ê³  ì—­ì‹œë‚˜ Androidì—ì„œ ì œê³µí•˜ëŠ” classê°€ ì¡´ì¬í•œë‹¤.  
  
```cpp  
using namespace android;  
  
Mutex mutex;  
Condition cond;  
class Producer: public Thread  
{  
public:  
	bool threadLoop()  
	{  
		Mutex::Autolock ll(mutex);  
		for(int i=0; i<3; i++)  
		{  
			sleep(1);  
			printf("ìƒì‚°ì¤‘â€¦\n");  
		}  
		printf("ìƒì‚°ì™„ë£Œ\n");  
		cond.signal();  
				  
		return false;  
	}  
};  
class Consumer : public Thread  
{  
public:  
	bool threadLoop()  
	{  
		Mutex::Autolock ll(mutex);  
		cond.wait(mutex);  
		for(int i=0; i<3; i++)  
		{  
			sleep(1);  
			printf("ì†Œë¹„ì¤‘â€¦\n");  
		}  
		printf("ì†Œë¹„ì™„ë£Œ\n");  
				  
		return false;  
	}  
};  
```  
  
íŠ¹ì´í•œ ì ì€ `signal()`ê³¼ `broadcast()`ê°€ ìˆë‹¤ëŠ” ì ì´ë‹¤.  
broadcast APIëŠ” ì—¬ëŸ¬ ì“°ë ˆë“œì—ê²Œ ì‹ í˜¸ë¥¼ ë³´ë‚¼ ìˆ˜ ìˆì–´ í¸ë¦¬í•˜ë‹¤.  
